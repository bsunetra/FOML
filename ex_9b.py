# -*- coding: utf-8 -*-
"""ex_9b.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uf9xIkv-yCjEG5CrVcwb2uXHRnVHMmXb
"""

import numpy as np
import pandas as pd
from math import sqrt

# -----------------------------
# Load the dataset
# -----------------------------
data = pd.read_csv('../input/k-means-clustering/KNN (3).csv')
req_data = data.iloc[:, 1:]   # ignoring ID column

# Shuffle rows
shuffle_index = np.random.permutation(req_data.shape[0])
req_data = req_data.iloc[shuffle_index]

print(req_data.head())

# -----------------------------
# Train/Test Split (70/30)
# -----------------------------
train_size = int(req_data.shape[0] * 0.7)
train_df = req_data.iloc[:train_size]
test_df  = req_data.iloc[train_size:]

train = train_df.values
test  = test_df.values

y_true = test[:, -1]

print("Train Shape:", train_df.shape)
print("Test Shape :", test_df.shape)

# -----------------------------
# Euclidean Distance Function
# -----------------------------
def euclidean_distance(x_test, x_train):
    distance = 0
    for i in range(len(x_test) - 1):   # ignore label column
        distance += (x_test[i] - x_train[i]) ** 2
    return sqrt(distance)

# -----------------------------
# Find K Nearest Neighbors
# -----------------------------
def get_neighbors(x_test, x_train, k):
    distances = []

    for row in x_train:
        distances.append(euclidean_distance(x_test, row))

    distances = np.array(distances)
    sorted_idx = distances.argsort()           # nearest first
    nearest_rows = x_train[sorted_idx][:k]     # pick top k

    return nearest_rows

# -----------------------------
# Predict class for ONE sample
# -----------------------------
def predict_one(x_test, x_train, k):
    neighbors = get_neighbors(x_test, x_train, k)
    classes = [row[-1] for row in neighbors]
    predicted_class = max(classes, key=classes.count)
    return predicted_class

# -----------------------------
# Predict class for TEST set
# -----------------------------
y_pred = []
for row in test:
    y_pred.append(predict_one(row, train, 5))   # k = 5

# -----------------------------
# Accuracy function
# -----------------------------
def accuracy_score(y_true, y_pred):
    correct = 0
    for i in range(len(y_true)):
        if y_true[i] == y_pred[i]:
            correct += 1
    return correct / len(y_true)

# -----------------------------
# Final Accuracy
# -----------------------------
acc = accuracy_score(y_true, y_pred)
acc